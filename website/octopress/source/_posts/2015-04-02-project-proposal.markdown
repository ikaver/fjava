---
layout: post
title: "Project Proposal"
date: 2015-04-02 02:09:42 -0400
comments: true
categories: 
---

**Summary**: 

We are going to implement a minimalistic high level cilk implementation for the Java programming language. Additionally, we will compare the performance of different scheduling and job stealing strategies for the framework.

**Background**: 

Fork join model is a natural way to express independent work inherent in divide and conquer algorithms. Many divide and conquer problems can gain almost a linear speedup with the number of processors when a lightweight, efficient fork join framework is used for parallelism.

One such framework for expressing work in fork join model is Cilk in C and C++. We want to implement a framework which allows programmers similar level of functionality in Java. Additionally, we want to take a fresh look at the existing ForkJoinPool by experimenting with different scheduling and work distribution strategies. Also, we intend to enhance the existing implementation by providing a APIs for better error reporting, performance metrics and simplicity.

Here is an example of our API:

``` java

public class Sorter<T> implements Runnable {

  private T [] array;
  private int left;
  private int right;
  private static final int LOCAL_SORT_DIFF = 10;
  
  public Sorter(T [] array, int left, int right) {
    this.array = array;
    this.left = left;
    this.right = right;
  }
  
  @Override
  public void run() {
    if(this.right-this.left <= LOCAL_SORT_DIFF) {
      //sort locally
      return;
    }
    int mid = (left+right) / 2;
    FJava fj = FJava.getInstance();
    JobToken token = fj.createJob();
    fj.runAsync(new Sorter<T>(array, left, mid), token);
    new Sorter<T>(array, mid+1, right).run();
    fj.sync(token);
  }
}
```

**Challenges**: 

The dependencies in the fork-join model are usually described explicitly by the user code. We would like to figure out the dependencies at either compile or run time; an alternative would be to force the user to use framework level constructs for specifying them explicitly.
There usually exists high locality between the childs of a job and the creator of the child jobs. The scheduling and work stealing algorithms that we implement should exploit this characteristic of the jobs.
Understand and design different scheduling and work stealing strategies for several types of fork-join tasks.
Implementing work stealing algorithms can be interesting. How do we reduce contention? How do we minimize work imbalance?
We want to experiment with user provided hints for making scheduling decision. Specifically, we want to provide a mechanism for the user to indicate the characteristics of the work which could be used for making better scheduling decisions. The mechanism could either be annotations (preferable) or a function call(less preferable).
Generate a test suite that demonstrate the framework’s performance for real world divide and conquer tasks for different scheduling and work stealing algorithms.
Define a simple to use, friendly API for the framework.

Goals and deliverables: 

Plan to achieve:
Implement a correct, fork join framework for the Java programming language.
Implement at least 2 scheduling strategies and 2 work stealing strategies. 
If we implement the framework correctly and efficiently, we should expect almost a linear speedup in the number of cores of the machine. However, the speedup might not be idea due to communication costs and work imbalance problems that the framework may involve.
Implement code to report metrics of the framework. For instance, total job time, statistics about the spawned job execution times, statistics about the idleness of the threads, statistics about the queue length of each thread. This information can potentially help the user to tune the forkjoin properly for the machine (for example, using an optimal threshold level for stopping parallelism).
Compare the system to the current Java's implementation of ForkJoinPool, and also compare it to a basic threading model that uses a regular thread pool instead of a fork join thread pool.
Hope to achieve:
Outperform Java's implementation of ForkJoinPool under some workloads. 
Handling exceptions: Implement code to handle and report the exceptions generated by the user supplied code. 
Incorporate user supplied inputs for making smarter scheduling and workload distribution decisions.

**Presentation:**
We will do a live demo of our code. We will show the performance of the system under several workloads, and we will compare it to Java's ForkJoinPool implementation and the regular thread pool implementation.
We will show several graphs for different workloads:
* Job completion time for different pool sizes.
* Job completion time for different sequential threshold limits. 
* Job completion time for different scheduling and work stealing algorithms.
* Job completion time for Java's ForkJoinPool implementation and the regular thread pool implementation.
* Number of steals for different scheduling and work stealing algorithms.
* Average work time in the queue for different scheduling and work stealing algorithms.

**Platform choice:**
We will use the Java programming language for this project. 
Our idea is that the framework should perform well on any computer. The scheduling decisions are made accordingly to the underlying characteristics of the machine that is running the code.

**Resources:**
Our own computers. We might use latedays for testing under increased processor counts.
We will start our code base from scratch.
We will use this paper as a reference for implementing work stealing with Deques: Scheduling Parallel Programs by Work Stealing with Private Deques, by Acar, Chargueráud and Rainey. http://chargueraud.org/research/2013/ppopp/full.pdf
This paper might be interesting as well: Dynamic, Circular Work-Stealing Queue: http://neteril.org/~jeremie/Dynamic_Circular_Work_Queue.pdf


**Schedule:**

* Thursday, April 2nd: 
  +  Create project website.
  +  Finish project specification.
* Week of April 5th-April 11th:
  +  Design of the FJava API.
  +  Design and implement several test suites. Problems may include:
      1. Sorting
      2. Matrix multiplication
      3. Filter
      4. Map
      5. Convex Hull
      6. Reduce
  + Understand different scheduling and work stealing algorithms.
  + Naive implementation based on the API, with no job stealing.
* Week of April 12th, April 18th: Thursday, April 16th: Project checkpoint
  + Reevaluate design of the API. Make changes if needed.
  + Read research paper on a some scheduling and work stealing algorithms.
  + Finish implementation with at least one scheduling and work stealing algorithm.
  + Evaluate system performance and understand the bottlenecks.
* Week of April 19th, April 26th:
  + Implement and experiment with other scheduling and work stealing algorithms.
  + Start work on building the metric collection framework.
* Week of April 27th, May 3rd:
  + Finish work on metric collection framework.
  + Evaluate system performance and fine tune different parameters.
* Week of May 4th, May 11th: Project presentation
  + Try to finish stretch goals.
  + Polish final write up.
  + Create final graphs for the presentation.
  + Setup for the demo.


